{"version":3,"sources":["../../../../src/lib/firestore.ts"],"sourcesContent":["import {\r\n    collection,\r\n    addDoc,\r\n    getDocs,\r\n    getDoc,\r\n    doc,\r\n    query,\r\n    where,\r\n    orderBy,\r\n    limit,\r\n    startAfter,\r\n    onSnapshot,\r\n    Timestamp,\r\n    DocumentData,\r\n    QueryDocumentSnapshot,\r\n    Unsubscribe,\r\n    runTransaction,\r\n    increment,\r\n    updateDoc,\r\n    deleteDoc\r\n} from 'firebase/firestore';\r\nimport { db } from './firebase';\r\nimport { Story } from '@/interfaces/Story';\r\nimport { Comment } from '@/interfaces/Comment';\r\n\r\n// Firestore koleksiyon referansları\r\nconst storiesCollection = collection(db, 'stories');\r\nconst commentsCollection = collection(db, 'comments');\r\n\r\n/**\r\n * @deprecated Use getStoriesPaginated() instead for better performance\r\n * Tüm hikayeleri getir - SADECE GERIYE DÖNÜK UYUMLULUK İÇİN\r\n * ÖNEMLİ: Bu fonksiyon tüm koleksiyonu çeker, performans sorunu yaratır!\r\n */\r\nexport async function getStories(): Promise<Story[]> {\r\n    console.warn('⚠️ getStories() is deprecated. Use getStoriesPaginated() for better performance.');\r\n\r\n    try {\r\n        const q = query(storiesCollection, orderBy('createdAt', 'desc'));\r\n        const querySnapshot = await getDocs(q);\r\n\r\n        return querySnapshot.docs.map(doc => {\r\n            const data = doc.data();\r\n            return {\r\n                id: doc.id,\r\n                ...data,\r\n                createdAt: data.createdAt?.toDate() || new Date(),\r\n            } as Story;\r\n        });\r\n    } catch (error) {\r\n        console.error('Error fetching stories:', error);\r\n        return [];\r\n    }\r\n}\r\n\r\n/**\r\n * Tek bir hikaye getir - OPTIMIZE EDİLDİ\r\n * Artık tüm hikayeleri çekmek yerine sadece ilgili dokümanı çeker\r\n */\r\nexport async function getStoryById(id: string): Promise<Story | null> {\r\n    try {\r\n        const storyRef = doc(db, 'stories', id);\r\n        const storyDoc = await getDoc(storyRef);\r\n\r\n        if (!storyDoc.exists()) {\r\n            return null;\r\n        }\r\n\r\n        const data = storyDoc.data();\r\n        return {\r\n            id: storyDoc.id,\r\n            ...data,\r\n            createdAt: data.createdAt?.toDate() || new Date(),\r\n        } as Story;\r\n    } catch (error) {\r\n        console.error('Error fetching story:', error);\r\n        return null;\r\n    }\r\n}\r\n\r\n// Bir hikayeye ait yorumları getir\r\nexport async function getCommentsByStoryId(storyId: string): Promise<Comment[]> {\r\n    try {\r\n        const q = query(\r\n            commentsCollection,\r\n            where('storyId', '==', storyId),\r\n            orderBy('createdAt', 'desc')\r\n        );\r\n        const querySnapshot = await getDocs(q);\r\n\r\n        const comments = querySnapshot.docs.map(doc => {\r\n            const data = doc.data();\r\n            return {\r\n                id: doc.id,\r\n                ...data,\r\n                createdAt: data.createdAt?.toDate() || new Date(),\r\n            } as Comment;\r\n        });\r\n\r\n        // Nested yorumları organize et\r\n        return organizeComments(comments);\r\n    } catch (error) {\r\n        console.error('Error fetching comments:', error);\r\n        return [];\r\n    }\r\n}\r\n\r\n// Yorumları nested yapıya dönüştür\r\nfunction organizeComments(comments: Comment[]): Comment[] {\r\n    const commentMap = new Map<string, Comment>();\r\n    const rootComments: Comment[] = [];\r\n\r\n    // Tüm yorumları map'e ekle\r\n    comments.forEach(comment => {\r\n        commentMap.set(comment.id, { ...comment, replies: [] });\r\n    });\r\n\r\n    // Nested yapıyı oluştur\r\n    comments.forEach(comment => {\r\n        const commentWithReplies = commentMap.get(comment.id);\r\n        if (commentWithReplies) {\r\n            // Eğer parent yoksa root comment\r\n            rootComments.push(commentWithReplies);\r\n        }\r\n    });\r\n\r\n    return rootComments;\r\n}\r\n\r\n// Yeni yorum ekle\r\nexport async function addComment(comment: Omit<Comment, 'id' | 'createdAt'>): Promise<string> {\r\n    try {\r\n        const docRef = await addDoc(commentsCollection, {\r\n            ...comment,\r\n            createdAt: Timestamp.now(),\r\n        });\r\n        return docRef.id;\r\n    } catch (error) {\r\n        console.error('Error adding comment:', error);\r\n        throw error;\r\n    }\r\n}\r\n\r\n// Yeni hikaye ekle\r\nexport async function addStory(story: Omit<Story, 'id' | 'createdAt'>): Promise<string> {\r\n    try {\r\n        const docRef = await addDoc(storiesCollection, {\r\n            ...story,\r\n            createdAt: Timestamp.now(),\r\n        });\r\n        return docRef.id;\r\n    } catch (error) {\r\n        console.error('Error adding story:', error);\r\n        throw error;\r\n    }\r\n}\r\n\r\n// Hikaye görüntülenme sayısını artır (Transaction ile güvenli artırma)\r\nexport async function incrementStoryViews(storyId: string): Promise<void> {\r\n    try {\r\n        const storyRef = doc(db, 'stories', storyId);\r\n\r\n        await runTransaction(db, async (transaction) => {\r\n            const storyDoc = await transaction.get(storyRef);\r\n\r\n            if (!storyDoc.exists()) {\r\n                throw new Error('Story does not exist!');\r\n            }\r\n\r\n            // stats.views değerini 1 artır\r\n            transaction.update(storyRef, {\r\n                'stats.views': increment(1)\r\n            });\r\n        });\r\n    } catch (error) {\r\n        console.error('Error incrementing story views:', error);\r\n        // View count artırma hatası uygulamayı durdurmamalı\r\n        // Sadece log'la ve devam et\r\n    }\r\n}\r\n\r\n\r\n// Hikaye güncelle\r\nexport async function updateStory(storyId: string, updates: Partial<Story>): Promise<void> {\r\n    try {\r\n        const storyRef = doc(db, 'stories', storyId);\r\n        await updateDoc(storyRef, {\r\n            ...updates,\r\n            updatedAt: Timestamp.now()\r\n        });\r\n    } catch (error) {\r\n        console.error('Error updating story:', error);\r\n        throw error;\r\n    }\r\n}\r\n\r\n// Hikaye sil\r\nexport async function deleteStory(storyId: string): Promise<void> {\r\n    try {\r\n        const storyRef = doc(db, 'stories', storyId);\r\n        await deleteDoc(storyRef);\r\n    } catch (error) {\r\n        console.error('Error deleting story:', error);\r\n        throw error;\r\n    }\r\n}\r\n\r\n// ============================================\r\n// REALTIME LISTENERS\r\n// ============================================\r\n\r\n/**\r\n * Subscribe to stories with realtime updates\r\n */\r\nexport function subscribeToStories(\r\n    callback: (stories: Story[]) => void,\r\n    limitCount?: number\r\n): Unsubscribe {\r\n    const q = limitCount\r\n        ? query(storiesCollection, orderBy('createdAt', 'desc'), limit(limitCount))\r\n        : query(storiesCollection, orderBy('createdAt', 'desc'));\r\n\r\n    return onSnapshot(q, (snapshot) => {\r\n        const stories = snapshot.docs.map(doc => {\r\n            const data = doc.data();\r\n            return {\r\n                id: doc.id,\r\n                ...data,\r\n                createdAt: data.createdAt?.toDate() || new Date(),\r\n            } as Story;\r\n        });\r\n        callback(stories);\r\n    }, (error) => {\r\n        console.error('Error in stories subscription:', error);\r\n    });\r\n}\r\n\r\n/**\r\n * Subscribe to a single story with realtime updates\r\n */\r\nexport function subscribeToStory(\r\n    storyId: string,\r\n    callback: (story: Story | null) => void\r\n): Unsubscribe {\r\n    const storyRef = doc(db, 'stories', storyId);\r\n\r\n    return onSnapshot(storyRef, (doc) => {\r\n        if (doc.exists()) {\r\n            const data = doc.data();\r\n            callback({\r\n                id: doc.id,\r\n                ...data,\r\n                createdAt: data.createdAt?.toDate() || new Date(),\r\n            } as Story);\r\n        } else {\r\n            callback(null);\r\n        }\r\n    }, (error) => {\r\n        console.error('Error in story subscription:', error);\r\n    });\r\n}\r\n\r\n/**\r\n * Subscribe to comments for a story with realtime updates\r\n */\r\nexport function subscribeToComments(\r\n    storyId: string,\r\n    callback: (comments: Comment[]) => void\r\n): Unsubscribe {\r\n    const q = query(\r\n        commentsCollection,\r\n        where('storyId', '==', storyId),\r\n        orderBy('createdAt', 'desc')\r\n    );\r\n\r\n    return onSnapshot(q, (snapshot) => {\r\n        const comments = snapshot.docs.map(doc => {\r\n            const data = doc.data();\r\n            return {\r\n                id: doc.id,\r\n                ...data,\r\n                createdAt: data.createdAt?.toDate() || new Date(),\r\n            } as Comment;\r\n        });\r\n        callback(organizeComments(comments));\r\n    }, (error) => {\r\n        console.error('Error in comments subscription:', error);\r\n    });\r\n}\r\n\r\n// ============================================\r\n// PAGINATION\r\n// ============================================\r\n\r\n/**\r\n * Get stories with pagination\r\n */\r\nexport async function getStoriesPaginated(\r\n    limitCount: number = 12,\r\n    lastDoc?: QueryDocumentSnapshot\r\n): Promise<{ stories: Story[]; lastDoc: QueryDocumentSnapshot | null }> {\r\n    try {\r\n        let q = query(\r\n            storiesCollection,\r\n            orderBy('createdAt', 'desc'),\r\n            limit(limitCount)\r\n        );\r\n\r\n        if (lastDoc) {\r\n            q = query(\r\n                storiesCollection,\r\n                orderBy('createdAt', 'desc'),\r\n                startAfter(lastDoc),\r\n                limit(limitCount)\r\n            );\r\n        }\r\n\r\n        const querySnapshot = await getDocs(q);\r\n\r\n        const stories = querySnapshot.docs\r\n            .map(doc => {\r\n                const data = doc.data();\r\n                return {\r\n                    id: doc.id,\r\n                    ...data,\r\n                    createdAt: data.createdAt?.toDate() || new Date(),\r\n                } as Story;\r\n            })\r\n            .filter(story => story.status !== 'DELETED');\r\n\r\n        const newLastDoc = querySnapshot.docs[querySnapshot.docs.length - 1] || null;\r\n\r\n        return { stories, lastDoc: newLastDoc };\r\n    } catch (error) {\r\n        console.error('Error fetching paginated stories:', error);\r\n        return { stories: [], lastDoc: null };\r\n    }\r\n}\r\n"],"names":[],"mappings":"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"}