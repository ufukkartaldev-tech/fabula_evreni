{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/90538/Desktop/fabula/benim-hikaye-uygulamasi/src/lib/firestore.ts"],"sourcesContent":["import {\r\n    collection,\r\n    addDoc,\r\n    getDocs,\r\n    getDoc,\r\n    doc,\r\n    query,\r\n    where,\r\n    orderBy,\r\n    limit,\r\n    startAfter,\r\n    onSnapshot,\r\n    Timestamp,\r\n    DocumentData,\r\n    QueryDocumentSnapshot,\r\n    Unsubscribe,\r\n    runTransaction,\r\n    increment,\r\n    updateDoc,\r\n    deleteDoc\r\n} from 'firebase/firestore';\r\nimport { db } from './firebase';\r\nimport { Story } from '@/interfaces/Story';\r\nimport { Comment } from '@/interfaces/Comment';\r\n\r\n// Firestore koleksiyon referansları\r\nconst storiesCollection = collection(db, 'stories');\r\nconst commentsCollection = collection(db, 'comments');\r\n\r\n/**\r\n * @deprecated Use getStoriesPaginated() instead for better performance\r\n * Tüm hikayeleri getir - SADECE GERIYE DÖNÜK UYUMLULUK İÇİN\r\n * ÖNEMLİ: Bu fonksiyon tüm koleksiyonu çeker, performans sorunu yaratır!\r\n */\r\nexport async function getStories(): Promise<Story[]> {\r\n    console.warn('⚠️ getStories() is deprecated. Use getStoriesPaginated() for better performance.');\r\n\r\n    try {\r\n        const q = query(storiesCollection, orderBy('createdAt', 'desc'));\r\n        const querySnapshot = await getDocs(q);\r\n\r\n        return querySnapshot.docs.map(doc => {\r\n            const data = doc.data();\r\n            return {\r\n                id: doc.id,\r\n                ...data,\r\n                createdAt: data.createdAt?.toDate() || new Date(),\r\n            } as Story;\r\n        });\r\n    } catch (error) {\r\n        console.error('Error fetching stories:', error);\r\n        return [];\r\n    }\r\n}\r\n\r\n/**\r\n * Tek bir hikaye getir - OPTIMIZE EDİLDİ\r\n * Artık tüm hikayeleri çekmek yerine sadece ilgili dokümanı çeker\r\n */\r\nexport async function getStoryById(id: string): Promise<Story | null> {\r\n    try {\r\n        const storyRef = doc(db, 'stories', id);\r\n        const storyDoc = await getDoc(storyRef);\r\n\r\n        if (!storyDoc.exists()) {\r\n            return null;\r\n        }\r\n\r\n        const data = storyDoc.data();\r\n        return {\r\n            id: storyDoc.id,\r\n            ...data,\r\n            createdAt: data.createdAt?.toDate() || new Date(),\r\n        } as Story;\r\n    } catch (error) {\r\n        console.error('Error fetching story:', error);\r\n        return null;\r\n    }\r\n}\r\n\r\n// Bir hikayeye ait yorumları getir\r\nexport async function getCommentsByStoryId(storyId: string): Promise<Comment[]> {\r\n    try {\r\n        const q = query(\r\n            commentsCollection,\r\n            where('storyId', '==', storyId),\r\n            orderBy('createdAt', 'desc')\r\n        );\r\n        const querySnapshot = await getDocs(q);\r\n\r\n        const comments = querySnapshot.docs.map(doc => {\r\n            const data = doc.data();\r\n            return {\r\n                id: doc.id,\r\n                ...data,\r\n                createdAt: data.createdAt?.toDate() || new Date(),\r\n            } as Comment;\r\n        });\r\n\r\n        // Nested yorumları organize et\r\n        return organizeComments(comments);\r\n    } catch (error) {\r\n        console.error('Error fetching comments:', error);\r\n        return [];\r\n    }\r\n}\r\n\r\n// Yorumları nested yapıya dönüştür\r\nfunction organizeComments(comments: Comment[]): Comment[] {\r\n    const commentMap = new Map<string, Comment>();\r\n    const rootComments: Comment[] = [];\r\n\r\n    // Tüm yorumları map'e ekle\r\n    comments.forEach(comment => {\r\n        commentMap.set(comment.id, { ...comment, replies: [] });\r\n    });\r\n\r\n    // Nested yapıyı oluştur\r\n    comments.forEach(comment => {\r\n        const commentWithReplies = commentMap.get(comment.id);\r\n        if (commentWithReplies) {\r\n            // Eğer parent yoksa root comment\r\n            rootComments.push(commentWithReplies);\r\n        }\r\n    });\r\n\r\n    return rootComments;\r\n}\r\n\r\n// Yeni yorum ekle\r\nexport async function addComment(comment: Omit<Comment, 'id' | 'createdAt'>): Promise<string> {\r\n    try {\r\n        const docRef = await addDoc(commentsCollection, {\r\n            ...comment,\r\n            createdAt: Timestamp.now(),\r\n        });\r\n        return docRef.id;\r\n    } catch (error) {\r\n        console.error('Error adding comment:', error);\r\n        throw error;\r\n    }\r\n}\r\n\r\n// Yeni hikaye ekle\r\nexport async function addStory(story: Omit<Story, 'id' | 'createdAt'>): Promise<string> {\r\n    try {\r\n        const docRef = await addDoc(storiesCollection, {\r\n            ...story,\r\n            createdAt: Timestamp.now(),\r\n        });\r\n        return docRef.id;\r\n    } catch (error) {\r\n        console.error('Error adding story:', error);\r\n        throw error;\r\n    }\r\n}\r\n\r\n// Hikaye görüntülenme sayısını artır (Transaction ile güvenli artırma)\r\nexport async function incrementStoryViews(storyId: string): Promise<void> {\r\n    try {\r\n        const storyRef = doc(db, 'stories', storyId);\r\n\r\n        await runTransaction(db, async (transaction) => {\r\n            const storyDoc = await transaction.get(storyRef);\r\n\r\n            if (!storyDoc.exists()) {\r\n                throw new Error('Story does not exist!');\r\n            }\r\n\r\n            // stats.views değerini 1 artır\r\n            transaction.update(storyRef, {\r\n                'stats.views': increment(1)\r\n            });\r\n        });\r\n    } catch (error) {\r\n        console.error('Error incrementing story views:', error);\r\n        // View count artırma hatası uygulamayı durdurmamalı\r\n        // Sadece log'la ve devam et\r\n    }\r\n}\r\n\r\n\r\n// Hikaye güncelle\r\nexport async function updateStory(storyId: string, updates: Partial<Story>): Promise<void> {\r\n    try {\r\n        const storyRef = doc(db, 'stories', storyId);\r\n        await updateDoc(storyRef, {\r\n            ...updates,\r\n            updatedAt: Timestamp.now()\r\n        });\r\n    } catch (error) {\r\n        console.error('Error updating story:', error);\r\n        throw error;\r\n    }\r\n}\r\n\r\n// Hikaye sil\r\nexport async function deleteStory(storyId: string): Promise<void> {\r\n    try {\r\n        const storyRef = doc(db, 'stories', storyId);\r\n        await deleteDoc(storyRef);\r\n    } catch (error) {\r\n        console.error('Error deleting story:', error);\r\n        throw error;\r\n    }\r\n}\r\n\r\n// ============================================\r\n// REALTIME LISTENERS\r\n// ============================================\r\n\r\n/**\r\n * Subscribe to stories with realtime updates\r\n */\r\nexport function subscribeToStories(\r\n    callback: (stories: Story[]) => void,\r\n    limitCount?: number\r\n): Unsubscribe {\r\n    const q = limitCount\r\n        ? query(storiesCollection, orderBy('createdAt', 'desc'), limit(limitCount))\r\n        : query(storiesCollection, orderBy('createdAt', 'desc'));\r\n\r\n    return onSnapshot(q, (snapshot) => {\r\n        const stories = snapshot.docs.map(doc => {\r\n            const data = doc.data();\r\n            return {\r\n                id: doc.id,\r\n                ...data,\r\n                createdAt: data.createdAt?.toDate() || new Date(),\r\n            } as Story;\r\n        });\r\n        callback(stories);\r\n    }, (error) => {\r\n        console.error('Error in stories subscription:', error);\r\n    });\r\n}\r\n\r\n/**\r\n * Subscribe to a single story with realtime updates\r\n */\r\nexport function subscribeToStory(\r\n    storyId: string,\r\n    callback: (story: Story | null) => void\r\n): Unsubscribe {\r\n    const storyRef = doc(db, 'stories', storyId);\r\n\r\n    return onSnapshot(storyRef, (doc) => {\r\n        if (doc.exists()) {\r\n            const data = doc.data();\r\n            callback({\r\n                id: doc.id,\r\n                ...data,\r\n                createdAt: data.createdAt?.toDate() || new Date(),\r\n            } as Story);\r\n        } else {\r\n            callback(null);\r\n        }\r\n    }, (error) => {\r\n        console.error('Error in story subscription:', error);\r\n    });\r\n}\r\n\r\n/**\r\n * Subscribe to comments for a story with realtime updates\r\n */\r\nexport function subscribeToComments(\r\n    storyId: string,\r\n    callback: (comments: Comment[]) => void\r\n): Unsubscribe {\r\n    const q = query(\r\n        commentsCollection,\r\n        where('storyId', '==', storyId),\r\n        orderBy('createdAt', 'desc')\r\n    );\r\n\r\n    return onSnapshot(q, (snapshot) => {\r\n        const comments = snapshot.docs.map(doc => {\r\n            const data = doc.data();\r\n            return {\r\n                id: doc.id,\r\n                ...data,\r\n                createdAt: data.createdAt?.toDate() || new Date(),\r\n            } as Comment;\r\n        });\r\n        callback(organizeComments(comments));\r\n    }, (error) => {\r\n        console.error('Error in comments subscription:', error);\r\n    });\r\n}\r\n\r\n// ============================================\r\n// PAGINATION\r\n// ============================================\r\n\r\n/**\r\n * Get stories with pagination\r\n */\r\nexport async function getStoriesPaginated(\r\n    limitCount: number = 12,\r\n    lastDoc?: QueryDocumentSnapshot\r\n): Promise<{ stories: Story[]; lastDoc: QueryDocumentSnapshot | null }> {\r\n    try {\r\n        let q = query(\r\n            storiesCollection,\r\n            orderBy('createdAt', 'desc'),\r\n            limit(limitCount)\r\n        );\r\n\r\n        if (lastDoc) {\r\n            q = query(\r\n                storiesCollection,\r\n                orderBy('createdAt', 'desc'),\r\n                startAfter(lastDoc),\r\n                limit(limitCount)\r\n            );\r\n        }\r\n\r\n        const querySnapshot = await getDocs(q);\r\n\r\n        const stories = querySnapshot.docs.map(doc => {\r\n            const data = doc.data();\r\n            return {\r\n                id: doc.id,\r\n                ...data,\r\n                createdAt: data.createdAt?.toDate() || new Date(),\r\n            } as Story;\r\n        });\r\n\r\n        const newLastDoc = querySnapshot.docs[querySnapshot.docs.length - 1] || null;\r\n\r\n        return { stories, lastDoc: newLastDoc };\r\n    } catch (error) {\r\n        console.error('Error fetching paginated stories:', error);\r\n        return { stories: [], lastDoc: null };\r\n    }\r\n}\r\n"],"names":[],"mappings":"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"}}]
}